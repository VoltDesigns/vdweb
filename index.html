<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture App Launcher</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #2d3748;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            width: 100%;
            max-width: 600px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative; /* Needed for absolute positioning of gesture zone */
        }
        video {
            width: 100%;
            max-height: 400px;
            background-color: #e2e8f0;
            border-radius: 1rem;
            object-fit: cover;
            border: 2px solid #a0aec0;
        }
        canvas {
            display: none; /* Hidden canvas for processing frames */
        }
        .control-buttons {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-image: linear-gradient(to right, #6366f1, #8b5cf6);
            color: white;
            border: none;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(99, 102, 241, 0.4);
        }
        button:disabled {
            background-image: none;
            background-color: #cbd5e0;
            cursor: not-allowed;
            box-shadow: none;
            color: #718096;
        }
        .message-box {
            background-color: #e0f2fe;
            color: #0c4a6e;
            padding: 1rem;
            border-radius: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
            min-height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            border: 1px solid #90cdf4;
        }
        .app-screen {
            display: none; /* Hidden by default */
            background-color: #ecfdf5;
            color: #065f46;
            padding: 2rem;
            border-radius: 1rem;
            border: 2px solid #34d399;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }
        .app-screen h2 {
            font-size: 2rem;
            font-weight: 700;
            color: #047857;
        }
        .app-screen p {
            font-size: 1.1rem;
            color: #065f46;
        }

        /* Gesture zone visual indicator */
        .gesture-zone-indicator {
            position: absolute;
            border: 3px dashed #f6ad55; /* Orange dashed border */
            border-radius: 0.5rem;
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 10;
            opacity: 0.7;
            box-shadow: 0 0 10px rgba(246, 173, 85, 0.5);
            transition: all 0.3s ease-in-out;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            .control-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-gray-800">Gesture App Launcher ðŸ“±</h1>
        <p class="text-gray-600">Simulate launching an app with motion gestures detected by your camera.</p>

        <div id="cameraView">
            <video id="webcamFeed" autoplay playsinline muted></video>
            <div id="gestureZoneIndicator" class="gesture-zone-indicator"></div>
        </div>
        <canvas id="gestureCanvas" width="640" height="480"></canvas>
        <canvas id="prevFrameCanvas" width="640" height="480"></canvas> <!-- Canvas to store previous frame -->

        <div class="control-buttons">
            <button id="startCameraButton">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-4 3 3 5-5V15z" />
                </svg>
                Start Camera
            </button>
            <button id="stopCameraButton" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                </svg>
                Stop Camera
            </button>
            <button id="toggleScanButton" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" />
                </svg>
                Start Continuous Scan
            </button>
        </div>

        <div id="messageDisplay" class="message-box">
            Click 'Start Camera' to begin.
        </div>

        <div id="appScreen" class="app-screen">
            <h2>ðŸŽ‰ My Cool App Launched! ðŸŽ‰</h2>
            <p>This is a simulated application. Imagine this is where your desired app would open.</p>
            <p>You can customize this content to anything you like.</p>
            <button id="backToCamera" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd" />
                </svg>
                Go Back to Camera
            </button>
        </div>
    </div>

    <script>
        // Get references to DOM elements
        const webcamFeed = document.getElementById('webcamFeed');
        const gestureCanvas = document.getElementById('gestureCanvas');
        const prevFrameCanvas = document.getElementById('prevFrameCanvas'); // Canvas for previous frame
        const messageDisplay = document.getElementById('messageDisplay');
        const startCameraButton = document.getElementById('startCameraButton');
        const stopCameraButton = document.getElementById('stopCameraButton');
        const toggleScanButton = document.getElementById('toggleScanButton');
        const cameraView = document.getElementById('cameraView');
        const appScreen = document.getElementById('appScreen');
        const backToCameraBtn = document.getElementById('backToCamera');
        const gestureZoneIndicator = document.getElementById('gestureZoneIndicator');

        const ctx = gestureCanvas.getContext('2d');
        const prevCtx = prevFrameCanvas.getContext('2d');

        let mediaStream = null;
        let animationFrameId = null;
        let isScanning = false;
        let gestureDetected = false;

        // Constants for gesture detection
        const GESTURE_ZONE_WIDTH_PERCENT = 0.4; // 40% of video width
        const GESTURE_ZONE_HEIGHT_PERCENT = 0.4; // 40% of video height
        const MOTION_THRESHOLD = 20; // Minimum pixel intensity difference for motion
        const MOTION_PIXEL_PERCENT_THRESHOLD = 0.05; // 5% of pixels in ROI must show motion

        /**
         * Calculates the position and size of the gesture zone indicator
         * relative to the video feed.
         */
        function updateGestureZoneIndicator() {
            if (!webcamFeed.videoWidth || !webcamFeed.videoHeight) {
                gestureZoneIndicator.style.display = 'none';
                return;
            }
            gestureZoneIndicator.style.display = 'block';

            const videoRect = webcamFeed.getBoundingClientRect();
            const containerRect = cameraView.getBoundingClientRect(); // Use cameraView as reference for positioning

            // Calculate gesture zone dimensions relative to video
            const zoneWidth = webcamFeed.videoWidth * GESTURE_ZONE_WIDTH_PERCENT;
            const zoneHeight = webcamFeed.videoHeight * GESTURE_ZONE_HEIGHT_PERCENT;

            // Calculate position to center the zone
            const zoneLeft = (webcamFeed.videoWidth - zoneWidth) / 2;
            const zoneTop = (webcamFeed.videoHeight - zoneHeight) / 2;

            // Scale these values to CSS pixels based on video's displayed size
            const scaleX = videoRect.width / webcamFeed.videoWidth;
            const scaleY = videoRect.height / webcamFeed.videoHeight;

            gestureZoneIndicator.style.width = `${zoneWidth * scaleX}px`;
            gestureZoneIndicator.style.height = `${zoneHeight * scaleY}px`;
            gestureZoneIndicator.style.left = `${videoRect.left - containerRect.left + (zoneLeft * scaleX)}px`;
            gestureZoneIndicator.style.top = `${videoRect.top - containerRect.top + (zoneTop * scaleY)}px`;
        }

        /**
         * Initializes the webcam feed.
         * Requests camera access and streams it to the video element.
         */
        async function startCamera() {
            try {
                // Request access to the user's camera
                mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } }); // Prefer front camera
                webcamFeed.srcObject = mediaStream;
                webcamFeed.onloadedmetadata = () => {
                    webcamFeed.play(); // Start playing the video once metadata is loaded
                    // Set canvas dimensions to match video feed
                    gestureCanvas.width = webcamFeed.videoWidth;
                    gestureCanvas.height = webcamFeed.videoHeight;
                    prevFrameCanvas.width = webcamFeed.videoWidth;
                    prevFrameCanvas.height = webcamFeed.videoHeight;

                    messageDisplay.textContent = "Camera active. Toggle 'Continuous Scan' to start detecting gestures.";
                    startCameraButton.disabled = true;
                    stopCameraButton.disabled = false;
                    toggleScanButton.disabled = false;

                    updateGestureZoneIndicator(); // Position the indicator
                    window.addEventListener('resize', updateGestureZoneIndicator); // Update on resize
                };
            } catch (err) {
                console.error("Error accessing camera:", err);
                messageDisplay.textContent = "Failed to start camera. Please ensure camera access is granted.";
                startCameraButton.disabled = false;
                stopCameraButton.disabled = true;
                toggleScanButton.disabled = true;
            }
        }

        /**
         * Stops the webcam feed.
         * Stops all tracks in the media stream and clears the video source.
         */
        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                webcamFeed.srcObject = null;
                mediaStream = null;
                cancelAnimationFrame(animationFrameId); // Stop the animation loop
                isScanning = false;
                toggleScanButton.textContent = 'Start Continuous Scan';
                toggleScanButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"> <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" /> </svg> Start Continuous Scan`;
                messageDisplay.textContent = "Camera stopped. Click 'Start Camera' to resume.";
                startCameraButton.disabled = false;
                stopCameraButton.disabled = true;
                toggleScanButton.disabled = true;
                gestureZoneIndicator.style.display = 'none'; // Hide indicator
                window.removeEventListener('resize', updateGestureZoneIndicator);
            }
        }

        /**
         * Toggles continuous gesture scanning.
         */
        function toggleContinuousScan() {
            if (!mediaStream) {
                messageDisplay.textContent = "Please start the camera first.";
                return;
            }

            isScanning = !isScanning;
            if (isScanning) {
                toggleScanButton.textContent = 'Stop Continuous Scan';
                toggleScanButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"> <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /> </svg> Stop Continuous Scan`;
                messageDisplay.textContent = "Continuous scanning active. Place your hand in the dashed box to launch the app.";
                gestureZoneIndicator.style.borderColor = '#f6ad55'; // Active color
                // Capture initial frame for motion detection
                ctx.drawImage(webcamFeed, 0, 0, gestureCanvas.width, gestureCanvas.height);
                prevCtx.drawImage(gestureCanvas, 0, 0); // Copy current frame to previous frame canvas
                startDetectionLoop();
            } else {
                toggleScanButton.textContent = 'Start Continuous Scan';
                toggleScanButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"> <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd" /> </svg> Start Continuous Scan`;
                messageDisplay.textContent = "Continuous scanning paused.";
                cancelAnimationFrame(animationFrameId);
                gestureZoneIndicator.style.borderColor = '#cbd5e0'; // Paused color
            }
        }

        /**
         * Animation loop for continuous gesture detection.
         */
        function startDetectionLoop() {
            if (!isScanning || gestureDetected) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            // Draw current video frame to gesture canvas
            ctx.drawImage(webcamFeed, 0, 0, gestureCanvas.width, gestureCanvas.height);

            // Calculate gesture zone coordinates
            const roiWidth = gestureCanvas.width * GESTURE_ZONE_WIDTH_PERCENT;
            const roiHeight = gestureCanvas.height * GESTURE_ZONE_HEIGHT_PERCENT;
            const roiX = (gestureCanvas.width / 2) - (roiWidth / 2);
            const roiY = (gestureCanvas.height / 2) - (roiHeight / 2);

            // Get image data for current and previous frames within the ROI
            const currentFrameData = ctx.getImageData(roiX, roiY, roiWidth, roiHeight).data;
            const prevFrameData = prevCtx.getImageData(roiX, roiY, roiWidth, roiHeight).data;

            let motionPixels = 0;
            const totalROIPixels = roiWidth * roiHeight;

            // Compare pixel data for motion detection
            for (let i = 0; i < currentFrameData.length; i += 4) {
                // Calculate average difference for RGB components
                const diff = Math.abs(currentFrameData[i] - prevFrameData[i]) + // R
                             Math.abs(currentFrameData[i+1] - prevFrameData[i+1]) + // G
                             Math.abs(currentFrameData[i+2] - prevFrameData[i+2]); // B

                if (diff / 3 > MOTION_THRESHOLD) { // If average difference exceeds threshold
                    motionPixels++;
                }
            }

            // If a significant percentage of pixels show motion, consider it a gesture
            if (motionPixels / totalROIPixels > MOTION_PIXEL_PERCENT_THRESHOLD) {
                messageDisplay.textContent = "Gesture detected! Launching My Cool App... ðŸŽ‰";
                launchApp();
                gestureDetected = true; // Prevent further detections until app is closed
            }

            // Copy current frame to previous frame canvas for the next iteration
            prevCtx.drawImage(gestureCanvas, 0, 0);

            animationFrameId = requestAnimationFrame(startDetectionLoop);
        }

        /**
         * Simulates launching an app by switching views.
         */
        function launchApp() {
            cameraView.style.display = 'none';
            appScreen.style.display = 'flex';
            cancelAnimationFrame(animationFrameId); // Stop camera loop
            stopCameraButton.disabled = true;
            toggleScanButton.disabled = true;
            isScanning = false;
        }

        /**
         * Returns from the simulated app to the camera view.
         */
        function returnToCameraView() {
            appScreen.style.display = 'none';
            cameraView.style.display = 'block';
            messageDisplay.textContent = "Returned to camera. Ready to scan again.";
            stopCameraButton.disabled = false;
            toggleScanButton.disabled = false;
            gestureDetected = false; // Reset gesture detection state
            toggleContinuousScan(); // Automatically resume scanning
        }

        // Event Listeners for buttons
        startCameraButton.addEventListener('click', startCamera);
        stopCameraButton.addEventListener('click', stopCamera);
        toggleScanButton.addEventListener('click', toggleContinuousScan);
        backToCameraBtn.addEventListener('click', returnToCameraView);

        // Initial state
        messageDisplay.textContent = "Click 'Start Camera' to begin.";

        // Ensure the gesture zone indicator is correctly positioned on video load
        webcamFeed.addEventListener('loadeddata', updateGestureZoneIndicator);
    </script>
</body>
</html>
